Async IO是一种并发编程设计，在Python中得到了专门的支持，从Python 3.4到3.7迅速发展，甚至[可能超越](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://twitter.com/1st1/status/1041855365745455104&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgGTCv0jExNiMXpr2sjP3rmg_Z3lA) 。

你可能会想到“并发，并行，线程，多处理”。 这已经很多了。 异步IO适合哪里？“

本教程旨在帮助您回答这个问题，让您更加深入地掌握Python的异步IO方法。

**以下是您将要介绍的内容：**

- **异步IO（异步IO）** ：与语言无关的范例（模型），具有跨多种编程语言的实现
- **async / await** ：两个用于定义协同程序的新Python关键字
- **asyncio** ：Python包，为运行和管理协同程序提供基础和API

协同程序（专用生成器函数）是Python中异步IO的核心，稍后我们将深入研究它们。

**注意** ：在本文中，我使用术语**async IO**来表示**异步IO**的语言无关设计，而`asyncio`指的是Python包。

在开始之前，您需要确保设置为使用本教程中的`asyncio`和其他库。

**免费奖励：** [关于Python掌握的5个想法](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/async-io-python/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiL1Xk3QWc_w5RYhDWXj8phEnjvRw) ，Python开发人员的免费课程，向您展示将Python技能提升到新水平所需的路线图和思维模式。

## 建立你的环境

您需要Python 3.7或更高版本来完整地阅读本文，以及`aiohttp`和`aiofiles`包：

```
 $ python3.7 -m venv ./py37async
 $ source ./py37async/bin/activate#Windows:./ py37async \ Scripts \ activate.bat
 $ pip install --upgrade pip aiohttp aiofiles ＃Optional：aiodns
```

有关安装Python 3.7和设置虚拟环境的帮助，请查看“ [Python 3安装和设置指南”](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/installing-python/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjsNiPdMtGYYL77d3e0af40KtaoqQ)或“ [虚拟环境入门”](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/python-virtual-environments-a-primer/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhOxDmX5HHkW4T7YsJ-Z2ButhNYpQ) 。

有了它，让我们跳进去吧。

## 10,000英尺的异步IO视图

Async IO比其久经考验的同类，多处理和线程更为人所知。 本节将为您提供有关异步IO以及它如何适应周围环境的更全面的图片。

### Async IO适合哪里？

并发和并行是广泛的主题，不容易涉及。 虽然本文主要关注异步IO及其在Python中的实现，但值得花一点时间将异步IO与其对应物进行比较，以便了解异步IO如何适应更大，有时令人眼花缭乱的难题。

**并行性**包括同时执行多个操作。 **多处理**是实现并行性的一种手段，它需要在计算机的中央处理单元（CPU或核心）上传播任务。 多处理非常适合CPU绑定任务：紧密绑定循环和数学计算通常属于此类别。

**并发性**是一个比并行性更广泛的术语。 它表明多个任务能够以重叠方式运行。 （有一种说法并发并不意味着并行性。）

**线程**是一种并发执行模型，多个[线程](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Thread_(computing)&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhiYU5nH_nV_o4GQ5XmdHcl-PAXSw)轮流执行任务。 一个进程可以包含多个线程。 由于它的[GIL](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/python-gil/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjz97tiQYiTwKq0TsJwF535l-s4Sw) ，Python与线程有着复杂的关系，但这超出了本文的范围。

了解线程的重要之处在于它对IO绑定任务更好。 虽然CPU绑定任务的特点是计算机的核心从头到尾不断努力，但是一个IO绑定的工作主要是需要等待很多输入/输出才能完成。

回顾上述情况，并发性包括多处理（适用于CPU绑定任务）和线程（适用于IO绑定任务）。 多处理是一种并行形式，并行性是并发的特定类型（子集）。 Python标准库通过其`multiprocessing` ， `threading`和`concurrent.futures`包提供[了对这两者的](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/concurrency.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjvMHrv4MKZU4I9GoF6T-_lSYsmPg)长期[支持](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/concurrency.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjvMHrv4MKZU4I9GoF6T-_lSYsmPg) 。

现在是时候带来一个新成员了。 在过去几年中，CPython中更加全面地构建了一个单独的设计：异步IO，通过标准库的`asyncio`包和新的`async`以及`await`语言关键字启用。 需要明确的是，异步IO不是新发明的概念，它已经存在或正在构建到其他语言和运行时环境中，例如[Go](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://gobyexample.com/goroutines&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgRjsYEFCoAWxx0jyQgsjwDEngZSA) ， [C＃](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.microsoft.com/en-us/dotnet/csharp/async&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiAPRt7I_HuNbJmywXZMHRGbfU_Kg)或[Scala](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.scala-lang.org/sips/async.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjsMiYahGT2dus9_7MPgt6TUsOc1Q) 。

Python文档将`asyncio`包称为[用于编写并发代码的库](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/asyncio.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgTlo9cE6g4bTCZ5V4YITTrKQNbYw) 。 但是，异步IO不是线程，也不是多处理。 它不是建立在其中任何一个之上。

事实上，异步IO是一种单线程，单进程设计：它使用**协作式多任务处理** ，这个术语在本教程结束时将会充实。 换句话说，尽管在单个进程中使用单个线程，但async IO给人一种并发感。 协同程序（异步IO的核心功能）可以同时调度，但它们本身并不是并发的。

重申一下，async IO是一种并发编程风格，但它并不是并行性。 与多线程处理相比，它与线程更紧密地对齐，但与这两者非常不同，并且是并发技巧的独立成员。

这留下了一个词。 什么是**异步的意思** ？ 这不是一个严格的定义，但出于我们的目的，我可以想到两个属性：

- 异步例程能够在等待其最终结果时“暂停”，并允许其他例程同时运行。
- 通过上面的机制，异步代码便于并发执行。 换句话说，异步代码提供了并发的外观和感觉。

这是一个将所有内容组合在一起的图表。 白色术语代表概念，绿色术语代表实现或实现它们的方式：

[![并发与并行](https://files.realpython.com/media/Screen_Shot_2018-10-17_at_3.18.44_PM.c02792872031.jpg)](https://files.realpython.com/media/Screen_Shot_2018-10-17_at_3.18.44_PM.c02792872031.jpg)

我将在那里停止并发编程模型之间的比较。 本教程重点介绍async IO的子组件，如何使用它，以及围绕它创建的API。 有关线程与多处理与异步IO的全面探索，请暂停并查看Jim Anderson对[Python中并发性](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/python-concurrency/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj7jlHmShkPasEhJes3KiLWOSQXTQ)的[概述](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/python-concurrency/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj7jlHmShkPasEhJes3KiLWOSQXTQ) 。 吉姆比我更有趣，并且参加了比我更多的会议，开机。

### Async IO解释

Async IO最初可能看起来违反直觉和矛盾。 有助于并发代码的东西如何使用单个线程和单个CPU核心？ 我从来都不擅长编写实例，所以我想从Miguel Grinberg的2017 PyCon演讲中解释一个，它解释了一切非常精美：

> 国际象棋大师JuditPolgár举办了一个国际象棋展览会，在那里她扮演多个业余选手。 她有两种方式进行展览：同步和异步。
>
> 假设：
>
> - 24个对手
> - Judit让每个国际象棋在5秒内移动
> - 反对者每人需要55秒才能采取行动
> - 游戏平均30对移动（总共60次移动）
>
> **同步版本** ：Judit一次玩一个游戏，而不是同时玩两个游戏，直到游戏完成。 每场比赛需要*（55 + 5）\* 30 == 1800*秒，或30分钟。 整个展览需要*24 \* 30 == 720*分钟，或**12小时** 。
>
> **异步版本** ：Judit从一个表移动到另一个表，在每个表上移动一次。 她离开桌子，让对手在等待期间进行下一步行动。 所有24场比赛的一举一动都是Judit *24 \* 5 == 120*秒，或2分钟。 整个展览现在减少到*120 \* 30 == 3600*秒，或仅**1小时** 。 [（资源）](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/iG6fr81xHKA%3Ft%3D4m29s&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhioQN8qc5Zk9Q0VpkPphn1rhfG8fQ)

只有一个JuditPolgár，她只有两只手，一次只做一次动作。 但是，异步播放将展览时间从12小时减少到1小时。 因此，合作多任务是一种奇特的方式，可以说程序的事件循环（稍后会详细介绍）与多个任务进行通信，让每个任务在最佳时间轮流运行。

Async IO需要很长的等待时间，否则函数会阻塞，并允许其他函数在停机期间运行。（一种有效阻止的功能，禁止其他人从启动到返回时运行。）

### 异步IO并不容易

我听说过，“尽可能使用异步IO; 必要时使用线程。“事实是，构建持久的多线程代码可能很难并且容易出错。 Async IO避免了一些线程设计可能遇到的潜在速度障碍。

但这并不是说Python中的异步IO很容易。 请注意：当您冒险低于表面水平时，异步编程也很困难！ Python的异步模型是围绕诸如回调，事件，传输，协议和未来等概念构建的 - 只是术语可能令人生畏。 事实上，它的API一直在不断变化，这使得它变得不容易。

幸运的是， `asyncio`已经成熟到其大部分功能不再具有临时性的程度，而其文档已经接受了大规模的改革，并且该主题的一些优质资源也开始出现。

## `asyncio`包和`async` / `await`

现在您已经了解了异步IO作为设计的背景知识，让我们来探索Python的实现。 Python的`asyncio`包（在Python 3.4中引入）及其两个关键字`async`和`await`用于不同的目的，但它们可以帮助您声明，构建，执行和管理异步代码。

### `async` / `await`语法和Native协同程序

**谨慎之处** ：小心你在互联网上读到的内容。 Python的异步IO API已经从Python 3.4迅速发展到Python 3.7。 不再使用一些旧的模式，现在允许通过新的介绍允许一些最初被禁止的东西。 据我所知，本教程也将很快加入过时的俱乐部。

协同IO的核心是协同程序。 协程是Python生成器函数的专用版本。 让我们从基线定义开始，然后在此处进行构建：coroutine是一个可以在到达`return`之前暂停其执行的函数，并且它可以间接地将控制传递给另一个协程一段时间。

之后，您将更深入地了解传统发电机如何重新用于协程。 目前，了解协程如何工作的最简单方法是开始制作一些协同程序。

让我们采用沉浸式方法并编写一些异步IO代码。 这个简短的程序是异步IO的`Hello World`，但在说明其核心功能方面还有很长的路要走：

```
  ＃！/ usr / bin / env python3
 #countasync.py

 导入 asyncio

 async def count （）：
     打印 （ “一个” ）
     等待 asyncio 。  睡觉 （ 1 ）
     打印 （ “两个” ）

 async def main （）：
     等待 asyncio 。  gather （ count （）， count （）， count （））

 如果 __name__ == “ __ main__ ” ：
     进口 时间
     s = 时间 。  perf_counter （）
     asyncio 。  run （ main （））
     已过去 = 时间 。  perf_counter （） - s
     print （ f {{__ file__} 在 {elapsed：0.2f} 秒内执行。“ ）
```

当您执行此文件时，请注意与仅使用`def`和`time.sleep()`定义函数时看起来不同的内容：

```
  $ python3 countasync.py
 一
 一
 一
 二
 二
 二
 countasync.py在1.01秒内执行。
```

此输出的顺序是异步IO的核心。 与每个对`count()`的调用交谈是单个事件循环或协调器。当每个任务到达`await asyncio.sleep(1)` ，该函数会向事件循环大喊并将控制权交还给它，说：“我将要睡1秒钟。 在此期间，继续做其他有意义的工作。“

将此与同步版本进行对比：

```
  ＃！/ usr / bin / env python3
 #countync.py

 进口 时间

 def count （）：
     打印 （ “一个” ）
     时间 。  睡觉 （ 1 ）
     打印 （ “两个” ）

 def main （）：
     for _ in range （ 3 ）：
         count （）

 如果 __name__ == “ __ main__ ” ：
     s = 时间 。  perf_counter （）
     main （）
     已过去 = 时间 。  perf_counter （） - s
     print （ f {{__ file__} 在 {elapsed：0.2f} 秒内执行。“ ）
```

执行时，顺序和执行时间会有轻微但严重的变化：

```
  $ python3 countsync.py
 一
 二
 一
 二
 一
 二
 在3.01秒内执行的countsync.py。
```

虽然使用`asyncio.sleep()` `time.sleep()`和`asyncio.sleep()`似乎是平庸的，但它们可用作任何涉及等待时间的时间密集型进程的替身。 （你可以等待的最平凡的事情是一个`sleep()`调用，基本上什么也没做。）也就是说， `time.sleep()`可以表示任何耗时的阻塞函数调用，而`asyncio.sleep()`用于表示对于非阻塞调用（但也需要一些时间来完成）。

正如您将在下一节中看到的，等待某些内容（包括`asyncio.sleep()`的好处是周围的函数可以暂时将控制权交给另一个能够立即执行某项操作的函数。 相反， `time.sleep()`或任何其他阻塞调用与异步Python代码不兼容，因为它将在休眠时间内停止其轨道中的所有内容。

### 异步IO规则

此时，他们创建的`async` ， `await`和coroutine函数的更正式定义是有序的。 这个部分有点密集，但是获取`async` / `await`是有帮助的，所以如果你需要，请回到这个：

- 语法`async def`引入了**本机协程**或**异步生成器** 。 `async with`和`async for`表达式也是有效的，稍后您将看到它们。
- 关键字`await`将函数控制传递回事件循环。 （它暂停执行周围的协程。）如果Python在`g()`的范围内遇到`await f()`表达式，这就是`await`告诉事件循环的方式，“暂停`g()`执行，直到我等待on - `f()`的结果 - 已返回。 与此同时，让其他东西运行。“

在代码中，第二个项目符号大致如下所示：

```
  async def g （）：
     ＃暂停此处并在f（）准备好后返回g（）
     r = 等待 f （）
     返回 河
```

关于何时以及如何能够和不能使用`async` / `await`还有一套严格的规则。 无论您是在使用语法还是已经使用`async` / `await`这些都非常方便：

- 您使用`async def`引入的函数是一个协程。 它可以使用`await` ， `return`或`yield` ，但所有这些都是可选的。 声明`async def noop(): pass`有效：
  - 使用`await`和/或`return`创建一个协程函数。 要调用协同程序函数，您必须`await`它才能获得结果。
  - 在`async def`块中使用`yield`不太常见（并且最近才在Python中合法）。 这将创建一个[异步生成器](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0525/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiVh16y2l_g-1xaF-MrrD50lrNGSQ) ，您可以使用[异步生成器](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0525/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiVh16y2l_g-1xaF-MrrD50lrNGSQ)进行迭代。 暂时忘掉异步生成器，重点关注使用`await`和/或`return`协程函数的语法。
  - 使用`async def`定义的任何内容都不能使用`yield from` ，这会引发`SyntaxError`。
- 就像在一个`def`函数之外使用`yield`的`SyntaxError` ，在`async def`协同程序之外使用`await`是一个`SyntaxError` 。 你只能在协同程序体中使用`await` 。

以下是一些简洁的例子，用于总结以上几条规则：

```
  async def f （ x ）：
     y = 等待 z （ x ） #OK  - 协同程序中允许的`await`和`return`
     回来

 async def g （ x ）：
     yield x ＃OK  - 这是一个异步生成器

 async def m （ x ）：
     来自 gen （ x ）的 产量 #No  -  SyntaxError

 def m （ x ）：
     y = 等待 z （ x ） ＃仍然没有 - 语法错误（这里没有`async def`）
     回来
```

最后，当你使用`await f()` ，要求`f()`是一个`await f()`的对象。 嗯，这不是很有帮助，是吗？ 现在，只要知道一个等待对象是（1）另一个协程或（2）定义`.__await__()` dunder方法的对象，它返回一个迭代器。 如果您正在编写程序，出于绝大多数目的，您只需要担心案例＃1。

这让我们看到了一个你可能会看到弹出的技术区别：一种将函数标记为协程的旧方法是使用`@asyncio.coroutine`来装饰正常的`def`函数。 结果是基于**生成器的协同程序** 。 由于在Python 3.5中实现了`async` / `await`语法，因此这种结构已经过时了。

这两个协程基本上是等价的（两者都是等待的），但第一个是**基于生成器的** ，而第二个是**本机协程** ：

```
  导入 asyncio

 @asyncio 。  协程
 def py34_coro （）：
     msgstr“”“基于生成器的协程，旧语法”“”
     来自 东西的 收益率 （）

 async def py35_coro （）：
     “”“原生协程，现代语法”“”
     等待 东西 （）
```

如果你自己编写任何代码，那么为了显而易见而不是隐式，更喜欢本地协程。 基于生成器的协同程序将在Python 3.10中[删除](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/asyncio-task.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjHQCHB_L3cZUeHXQYcZpK5kev_QQ#generator-based-coroutines) 。

在本教程的后半部分，我们将触及基于生成器的协同程序，仅用于解释。 引入`async` / `await`的原因是使协同程序成为Python的独立功能，可以很容易地与正常的生成器函数区分开来，从而减少歧义。

不要陷入基于生成器的协程中，这些协同程序已被`async` / `await` [故意过时](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0492/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj-vAvUSsoVkXqjv876EC8vutbf9A#rationale-and-goals) 。 它们有自己的一小组规则（例如， `await`不能用于基于生成器的协程），如果你坚持使用`async` / `await`语法，这些规则在很大程度上是不相关的。

不用多说，让我们来看几个更复杂的例子。

下面是异步IO如何减少等待时间的一个例子：给定一个coroutine `makerandom()` ，它在[ `makerandom()` ]范围内产生随机整数，直到其中一个超过阈值，你想让这个协同程序多次调用不需要等待对方连续完成。 你可以在很大程度上遵循上面两个脚本的模式，只需稍作修改：

```
  ＃！/ usr / bin / env python3
 #rand.py

 导入 asyncio
 随机 导入

 #ANSI颜色
 c = （
     “ \ 033 [0m” ， ＃颜色结束
     “ \ 033 [36m” ， ＃青色
     “ \ 033 [91m” ， ＃Red
     “ \ 033 [35m” ， ＃Magenta
 ）

 async def randint （ a ： int ， b ： int ） - > int ：
     随机 返回 。  兰丁 （ a ， b ）

 async def makerandom （ idx ： int ， threshold ： int = 6 ） - > int ：
     print （ c [ idx + 1 ] + f “Initiated makerandom（ {idx} ）。” ）
     i = 等待 randint （ 0,10 ）
     而 我 <= 阈值 ：
         print （ c [ idx + 1 ] + f “makerandom（ {idx} ）== {i} 太低;正在重试。” ）
         等待 asyncio 。  睡觉 （ idx + 1 ）
         i = 等待 randint （ 0,10 ）
     print （ c [ idx + 1 ] + f “--->已完成：makerandom（ {idx} ）== {i} ” + c [ 0 ]）
     回来 我

 async def main （）：
     res = 等待 asyncio 。  收集 （ * （ makerandom （ i ， 10 - i - 1 ） for i in range （ 3 ）））
     返回 资源

 如果 __name__ == “ __ main__ ” ：
     随机的 。  种子 （ 444 ）
     r1 ， r2 ， r3 = asyncio 。  run （ main （））
     print （）
     print （ f “r1： {r1} ，r2： {r2} ，r3： {r3} ” ）
```

彩色输出比我说的要多得多，让你对这个脚本的执行方式有所了解：

[![rand.py程序执行](https://files.realpython.com/media/asyncio-rand.dffdd83b4256.gif)](https://files.realpython.com/media/asyncio-rand.dffdd83b4256.gif)rand.py执行

该程序使用一个主协程`makerandom()` ，并在3个不同的输入上同时运行它。 大多数程序将包含小的模块化协程和一个包装函数，用于将每个较小的协程链接在一起。 然后， `main()`用于通过将中央协程映射到某个可迭代或池中来收集任务（期货）。

在这个微型示例中，池是`range(3)` 。 在稍后介绍的更全面的示例中，它是一组需要同时请求，解析和处理的URL，而`main()`封装了每个URL的整个例程。

虽然“制作随机整数”（CPU比任何东西更多）可能不是作为`asyncio`候选者的最佳选择，但是在示例中存在`asyncio.sleep()` ，旨在模仿IO绑定进程哪里有不确定的等待时间。 例如， `asyncio.sleep()`调用可能表示在消息应用程序中的两个客户端之间发送和接收不那么随机的整数。

## 异步IO设计模式

Async IO附带了一组可能的脚本设计，您将在本节中介绍它们。

### 链接协同程序

协同程序的一个关键特性是它们可以链接在一起。 （请记住，协程对象是等待的，所以另一个协程可以`await`它。）这允许您将程序分解为更小，可管理，可回收的协程：

```
  ＃！/ usr / bin / env python3
 #chained.py

 导入 asyncio
 随机 导入
 进口 时间

 async def randint （ a ： int ， b ： int ） - > int ：
     随机 返回 。  兰丁 （ a ， b ）

 async def part1 （ n ： int ） - > str ：
     i = 等待 randint （ 0,10 ）
     打印 （ f “part1（ {n} ）睡眠 {i} 秒。” ）
     等待 asyncio 。  睡觉 （ i ）
     result = f “result {n} -1”
     print （ f “返回part1（ {n} ）== {result} 。” ）
     返回 结果

 async def part2 （ n ： int ， arg ： str ） - > str ：
     i = 等待 randint （ 0,10 ）
     print （ f “part2 {n，arg}睡眠 {i} 秒。” ）
     等待 asyncio 。  睡觉 （ i ）
     result = f “result {n} -2派生自 {arg} ”
     print （ f “返回part2 {n，arg} == {result} 。” ）
     返回 结果

 异步定义 链 （ n ： int ） - > 无 ：
     开始 = 时间 。  perf_counter （）
     p1 = 等待 part1 （ n ）
     p2 = 等待 part2 （ n ， p1 ）
     结束 = 时间 。  perf_counter （） - 开始
     print （ f “ - >链式结果 {n} => {p2} （花了 {end：0.2f} 秒）。” ）

 async def main （ * args ）：
     等待 asyncio 。  聚集 （ * （ ar （ 链接 （ n ） 代表 ar ））

 如果 __name__ == “ __ main__ ” ：
     导入 系统
     随机的 。  种子 （ 444 ）
     args = [ 1,2,3 ] 如果 len （ sys.argv ） == 1 else map （ int ， sys.argv [ 1 ：]）
     开始 = 时间 。  perf_counter （）
     asyncio 。  run （ main （ * args ））
     结束 = 时间 。  perf_counter （） - 开始
     print （ f “程序在 {end：0.2f} 秒完成。” ）
```

注意输出，其中`part1()`睡眠的时间可变，而`part2()`开始使用结果，因为它们变得可用：

```
  $ python3 chained.py 9 6 3
 part1（9）睡了4秒钟。
 part1（6）睡4秒。
 part1（3）睡眠0秒。
 返回part1（3）== result3-1。
 part2（3，'result3-1'）睡了4秒钟。
 返回part1（9）== result9-1。
 part2（9，'result9-1'）睡了7秒钟。
 返回part1（6）== result6-1。
 part2（6，'result6-1'）睡了4秒钟。
 返回part2（3，'result3-1'）== result3-2派生自result3-1。
  - >链式result3 => result3-2派生自result3-1（耗时4.00秒）。
 返回part2（6，'result6-1'）== result6-2派生自result6-1。
  - >链式result6 => result6-2派生自result6-1（耗时8.01秒）。
 返回part2（9，'result9-1'）== result9-2派生自result9-1。
  - >链式result9 => result9-2派生自result9-1（耗时11.01秒）。
 程序在11.01秒内完成。
```

在此设置中， `main()`的运行时将等于它收集在一起的任务的最大运行时间和计划。

### 使用队列

`asyncio`包提供了与[`queue`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/queue.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhSZf8YBbn0xl8SZX3gfOJLqtFq1g#module-queue)模块的类相似的[`queue`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/queue.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhSZf8YBbn0xl8SZX3gfOJLqtFq1g#module-queue)类。 在我们到目前为止的示例中，我们并不真正需要队列结构。 在`chained.py` ，每个任务（将来）由一组协程组成，这些协同程序明确地等待彼此并通过每个链的单个输入。

还有一种替代结构也可以与异步IO一起使用：许多生成器（彼此不相关）将项添加到队列中。 每个生产者可以在交错，随机，未宣布的时间将多个项目添加到队列中。 一群消费者在他们出现时贪婪地从队列中拉出物品而不等待任何其他信号。

在这种设计中，没有任何个体消费者与生产者的链接。 消费者事先不知道生产者的数量，甚至不知道将添加到队列中的累计项目数。

它需要一个单独的生产者或消费者分别从队列中放入和提取项目的可变时间。 该队列用作吞吐量，可以与生产者和消费者进行通信，而无需他们直接相互通信。

**注意** ：虽然队列通常用于线程程序，因为`queue.Queue()`线程安全性，当涉及异步IO时，您不需要关心线程安全。 （例外情况是当你将两者合并时，但在本教程中没有这样做。）

队列的一个用例（就像这里的情况一样）是队列充当生产者和消费者的发送者，而这些生成者和消费者没有直接链接或相互关联。

该程序的同步版本看起来非常令人沮丧：一组阻塞生成器连续地向队列添加项目，一次一个生产者。 只有在完成所有生成器之后，才能由一个消费者逐个处理队列来处理队列。 这种设计存在大量延迟。 项目可能闲置在队列中，而不是立即拾取和处理。

异步版本`asyncq.py`如下所示。 该工作流程中具有挑战性的部分是需要向消费者发出生产完成的信号。 否则， `await q.get()`将无限期挂起，因为队列将被完全处理，但消费者不会知道生产已完成。

（非常感谢StackOverflow [用户](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://stackoverflow.com/a/52615705/7954504&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhigK_m-6nG8GkGTL51BfXhRZDb0-g)帮助理顺`main()`一些帮助：关键是`await q.join()` ，阻塞直到队列中的所有项都被接收和处理，然后取消消费者任务，否则会挂起并无休止地等待其他队列项出现。）

这是完整的脚本：

```
  ＃！/ usr / bin / env python3
 #asyncq.py

 导入 asyncio
 导入 itertools就好 了
 进口口
 随机 导入
 进口 时间

 async def makeitem （ size ： int = 5 ） - > str ：
     返回 os 。  urandom （ 大小 ） 。  十六进制 （）

 async def randint （ a ： int ， b ： int ） - > int ：
     随机 返回 。  兰丁 （ a ， b ）

 async def randsleep （ a ： int = 1 ， b ： int = 5 ， caller = None ） - > None ：
     i = 等待 randint （ a ， b ）
     如果 来电者 ：
         打印 （ f “ {caller} 睡眠 {i} 秒。” ）
     等待 asyncio 。  睡觉 （ i ）

 async def produce （ name ： int ， q ： asyncio.Queue ） - > None ：
     n = 等待 randint （ 1,5 ）
     为 _ 在 其中 。  repeat （ None ， n ）： ＃每个生产者的同步循环
         等待 randsleep （ caller = f “Producer {name} ” ）
         i = 等待 makeitem （）
         t = 时间 。  perf_counter （）
         等待 q 。  放 （（ i ， t ））
         print （ f “生产者 {name}已 添加< {i} >到队列。” ）

 async def consume （ name ： int ， q ： asyncio.Queue ） - > None ：
     而 真 ：
         等待 randsleep （ caller = f “Consumer {name} ” ）
         我 ， t = 等待 q 。  得到 （）
         现在 = 时间 。  perf_counter （）
         print （ f “Consumer {name} got element < {i} >”
               f “在{now-t：0.5f}秒内。”  ）
         q 。  task_done （）

 async def main （ nprod ： int ， ncon ： int ）：
     q = asyncio 。  队列 （）
     生产者 = [ asyncio 。  对于 范围内的 n （ nprod ） ， create_task （ produce （ n ， q ） ）]
     消费者 = [ asyncio 。  n （ 范围内的 ncon ）的 create_task （ consume （ n ， q ） ）]
     等待 asyncio 。  聚集 （ * 生产者 ）
     等待 q 。  join （） ＃隐含地等待消费者
     对于 消费者来说 ：
         c 。  取消 （）

 如果 __name__ == “ __ main__ ” ：
     import argparse
     随机的 。  种子 （ 444 ）
     parser = argparse 。  ArgumentParser （）
     解析器 。  add_argument （ “ -  p” ， “ -  nprod” ， type = int ， default = 5 ）
     解析器 。  add_argument （ “ -  c” ， “ -  ncon” ， type = int ， default = 10 ）
     ns = 解析器 。  parse_args （）
     开始 = 时间 。  perf_counter （）
     asyncio 。  run （ main （ ** ns 。__ dict__ ））
     已过去 = 时间 。  perf_counter （） - 开始
     print （ f “程序在 {elapsed：0.5f} 秒内完成。” ）
```

前几个协同程序是辅助函数，它返回随机字符串，小数秒性能计数器和随机整数。 生产者将1到5个项目放入队列中。 每个项目是`(i, t)`的元组，其中`i`是随机字符串， `t`是生产者尝试将元组放入队列的时间。

当消费者将项目拉出时，它只使用项目所在的时间戳计算项目在队列中所用的时间。

请记住， `asyncio.sleep()`用于模仿其他更复杂的协程，如果它是常规阻塞函数，会耗尽时间并阻止所有其他执行。

这是一个有两个生产者和五个消费者的测试：

```
  $ python3 asyncq.py -p 2 -c 5
 制片人0睡3秒钟。
 制片人1睡3秒钟。
 消费者0睡4秒钟。
 消费者1睡3秒钟。
 消费者2睡3秒钟。
 消费者3睡5秒钟。
 消费者4睡4秒钟。
 制作人0将<377b1e8f82>添加到队列中。
 制片人0睡5秒钟。
 制片人1将<413b8802f8>添加到队列中。
 消费者1在0.00013秒内得到元素<377b1e8f82>。
 消费者1睡3秒钟。
 消费者2在0.00009秒内得到元素<413b8802f8>。
 消费者2睡4秒钟。
 制作人0将<06c055b3ab>添加到队列中。
 制片人0睡1秒钟。
 消费者0在0.00021秒内得到元素<06c055b3ab>。
 消费者0睡4秒钟。
 生产者0将<17a8613276>添加到队列中。
 消费者4在0.00022秒内得到元素<17a8613276>。
 消费者4睡5秒钟。
 计划于9.00954秒完成。
```

在这种情况下，项目在几分之一秒内处理。 延迟可能有两个原因：

- 标准的，很大程度上是不可避免的开销
- 当项目出现在队列中时，所有消费者都在睡觉的情况

关于第二个原因，幸运的是，向数百或数千个消费者扩展是完全正常的。 你应该对`python3 asyncq.py -p 5 -c 100`没有问题。 这里的要点是，从理论上讲，您可以在控制生产者和消费者管理的不同系统上拥有不同的用户，并将队列作为中央吞吐量。

到目前为止，你已经被抛到了火中，并看到了`asyncio`调用与`async`和`await`定义的协同程序的三个相关示例。 如果您没有完全关注或者只是想深入了解Python中现代协同程序的机制，那么您将从下一部分的方形开始。

## 异步IO在生成器中的根源

之前，您看到了一个基于生成器的旧式协程的示例，这些协程已经过了更明确的本机协同程序。 这个例子值得重新展示一下：

```
  导入 asyncio

 @asyncio 。  协程
 def py34_coro （）：
     “”基于发电机的协程“”“
     ＃不需要自己构建这些，但要注意它们是什么
     s = 来自 stuff的 产量 （）
     回归

 async def py35_coro （）：
     “”“原生协程，现代语法”“”
     s = await stuff （）
     回归

 async def stuff （）：
     返回 0x10,0x20,0x30
```

作为一个实验，如果您自己调用`py34_coro()`或`py35_coro()` ，没有`await` ，或者没有调用`asyncio.run()`或其他`asyncio` “瓷器”函数会发生什么？ 单独调用一个协同程序会返回一个协同程序对象：

\>>>

```
  >>> py35_coro （）
 <coroutine object py35_coro at 0x10126dcc8>
```

这表面上并不是很有趣。 调用协同程序的结果是一个等待的**协程对象** 。

测验的时间：Python的其他功能是什么样的？ （当它自己被调用时，Python的哪些特性实际上并没有“做太多”？）

希望你将**发电机**作为这个问题的答案，因为协同程序是增强型发电机。在这方面的行为类似：

\>>>

```
 >>>  高清 根 （）：
...  产量 为0x10  ， 0x20的 ， 的0x30
 ...
>>>  g  =  gen  （）
>>>  g  ＃没有什么事情发生 - 需要迭代`.__ next __（）` 
<generator object gen at 0x1012705e8> 
>>>  next  （ g  ）
（16,32,48 ）
```

正如它所发生的那样，生成器函数是异步IO的基础（无论是否使用`async def`旧的`@asyncio.coroutine`包装器声明协同程序）。从技术上讲，`await`它更接近于`yield from`它`yield`。（但请记住，这`yield from x()`只是替代的语法糖`for i in x(): yield i`。）

与异步IO相关的生成器的一个关键特性是它们可以随意停止和重新启动。例如，您可以`break`不迭代生成器对象，然后稍后继续对剩余值进行迭代。当生成器函数到达时`yield`，它会产生该值，但随后它将处于空闲状态，直到它被告知产生其后续值。

这可以通过一个例子充实：

\>>>

```
 >>>  来自 itertools  导入 循环
>>>  def  endless  （）：
...  “”“收益率9,8,7,6,9,8,7,6，...永远”“” 
......  收益率 周期 （（ 9  ， 8  ， 7  ， 6  ））

>>>  e  =  endless  （）
>>>  total  =  0 
>>>  for  e  in  e  ：
...  如果 总 <  30  ：
...  print  （ i  ， end  =  “”  ）
...  total  + =  i 
。 ..  else  ：
...  print  （）
...  ＃暂停执行。我们可以稍后恢复。
...  休息
9 8 7 6 9 8 7 6 9 8 7 6 9 8

>>>  #Sresume 
>>>  next  （ e  ）， next  （ e  ）， next  （ e  ）
（6,9,8）
```

该`await`关键字的行为类似，标志着在该协程挂起本身，并让其他协同程序工作的一个破发点。在这种情况下，“暂停”是指暂时放弃控制但未完全退出或完成的协程。请记住`yield`，通过扩展，`yield from`并`await`在生成器的执行中标记一个断点。

这是函数和生成器之间的根本区别。功能是全有或全无。一旦它启动，它将不会停止，直到它命中`return`，然后将该值推送到调用者（调用它的函数）。另一方面，发电机每次击中时都会暂停`yield`，不再进一步。它不仅可以将此值推送到调用堆栈，而且可以在通过调用它来恢复它时保持其局部变量`next()`。

发电机的第二个也鲜为人知的特征也很重要。您也可以通过其`.send()`方法将值发送到生成器。这允许生成器（和协同程序）相互调用（`await`）而不会阻塞。我不会再深入了解这个功能的细节，因为它主要是为了在幕后实现协同程序，但你不应该真的需要自己直接使用它。

如果您有兴趣了解更多内容，可以从[PEP 342](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0342/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhibfLGOnbxaLjnIpVR12WxheeQE3A)开始，正式引入协同程序。 Brett Cannon的[Heck Async- ](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhmPB3072CN1ysUo--ncMXlPwvYww)[Await `asyncio`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://pymotw.com/3/asyncio/coroutines.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhigSwpwYsfm04J1n8Asiv2Im8zN0g)[如何在Python中工作](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhmPB3072CN1ysUo--ncMXlPwvYww)也是一个很好的阅读，正如[PYMOTW的写作一样](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://pymotw.com/3/asyncio/coroutines.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhigSwpwYsfm04J1n8Asiv2Im8zN0g)。最后，还有David Beazley [关于Coroutines和Concurrency](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://www.dabeaz.com/coroutines/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgKtXQSCKa1Vi_5pf93s8C5QzEAig)的[好奇课程](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://www.dabeaz.com/coroutines/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgKtXQSCKa1Vi_5pf93s8C5QzEAig)，它深入探讨了协同程序运行的机制。

让我们尝试将上述所有文章压缩成几句：有一种特殊的非常规机制，通过这种机制实际运行这些协同程序。它们的结果是异常对象的属性，在`.send()`调用其方法时会抛出该属性。对于所有这些都有一些更难以理解的细节，但它可能无法帮助你在实践中使用这部分语言，所以让我们继续前进。

为了将事物联系在一起，以下是关于协同作为生成器的主题的一些关键点：

- 协同程序是[重新利用的发电机](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0492/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj-vAvUSsoVkXqjv876EC8vutbf9A#differences-from-generators)，利用发电机方法的特殊性。
- 旧的基于生成器的协同程序用于`yield from`等待协程结果。在原生协程现代Python语法只是替换`yield from`与`await`作为等待协同程序结果的手段。这`await`类似于`yield from`，并且通常有助于将其视为这样。
- 使用`await`是标志着断点的信号。它允许协程暂时暂停执行并允许程序稍后返回它。

### 其他功能：`async for`和异步生成器+理解

与plain `async`/一起`await`，Python还可以`async for`迭代**异步迭代器**。异步迭代器的目的是让它能够在迭代时在每个阶段调用异步代码。

这个概念的自然延伸是**异步发生器**。回想一下，您可以使用`await`，`return`或`yield`在本地协程中使用。`yield`在Python 3.6中可以使用协程（通过PEP 525），它引入了异步生成器，目的是允许`await`和`yield`在同一个协程函数体中使用：

\>>>

```
 >>>  async  def  mygen  （ u  ： int  =  10  ）：
...  “”“屈服力2.”“” 
......  i  =  0 
...  而 我 <  u  ：
...  产生 2  **  i 
...  i  + =  1 
...  等待 asyncio  。 睡觉 （ 0.1  ）
```

最后但并非最不重要的，Python的允许**异步理解**与`async for`。就像它的同步表兄弟一样，这主要是语法糖：

\>>>

```
 >>>  异步 DEF  主 （）：
...  ＃这确实*不*介绍并发执行
...  ＃它是为了示出的语法只
...  克 =  [  我 ASYNC  用于 我 在 mygen  （）] 
...  ˚F  =  [  Ĵ  异步 为 Ĵ  在 mygen  （） 如果 不是 （ Ĵ  //  3  ％ 5  ）] 
...  返回 克 ， ˚F
 ...
>>>  g  ， f  =  asyncio  。 run  （ main  （））
>>>  g 
[1,2,4,8,16,32,64,128,256,512] 
>>>  f 
[1,2,16,32,256,512]
```

这是一个至关重要的区别：**异步生成器和理解都不会使迭代并发**。他们所做的只是提供同步对应的外观，但是有问题的循环能够放弃对事件循环的控制，以便运行其他协同程序。

换句话说，异步迭代器和异步生成器不是为了在序列或迭代器上同时映射某些函数而设计的。它们仅仅是为了让封闭的协程允许其他任务轮流使用。的`async for`和`async with`语句只需要在使用普通的程度`for`或`with`将“中断”的性质`await`在协程。异步性和并发性之间的区别是一个需要掌握的关键因素。

### 事件循环和 `asyncio.run()`

您可以将事件循环视为一个`while True`监视协同程序的循环，收集有关空闲内容的反馈，并查找可在此期间执行的内容。当协同程序等待的任何内容变得可用时，它能够唤醒空闲协程。

到目前为止，事件循环的整个管理已由一个函数调用隐式处理：

```
 asyncio  。 run  （ main  （）） ＃Python 3.7+
```

[`asyncio.run()`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/python/cpython/blob/d4c76d960b8b286b75c933780416ace9cda682fd/Lib/asyncio/runners.py&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhi_OYy1z2gxHWgi2YpfSf6GARIz7Q#L8) 在Python 3.7中引入，负责获取事件循环，运行任务直到它们被标记为完成，然后关闭事件循环。

有一个更加冗长的方式来管理`asyncio`事件循环`get_event_loop()`。典型的模式如下所示：

```
 loop  =  asyncio  。 get_event_loop  （）
尝试 ：
     循环 。 run_until_complete  （ main  （））
最后 ：
     循环 。 关闭 （）
```

您可能会看到`loop.get_event_loop()`在旧示例中浮动，但除非您特别需要微调对事件循环管理的控制，`asyncio.run()`否则对大多数程序来说应该足够了。

如果你确实需要在Python程序中与事件循环进行交互，那么它`loop`是一个老式的Python对象，支持使用`loop.is_running()`和进行内省`loop.is_closed()`。如果需要获得更精细的控制，可以对其进行操作，例如通过将循环作为参数传递来[调度回调](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/asyncio-eventloop.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgmAsUGarQHOht7DzNY0CR2q3f46w#asyncio-example-lowlevel-helloworld)。

更重要的是理解表面下有关事件循环机制的一点。以下是值得强调事件循环的几点。

**＃1：**协同程序在与事件循环绑定之前不会自行做很多事情。

你之前在发电机的解释中看到了这一点，但值得重申。如果你有一个等待其他人的主协程，那么简单地单独调用它几乎没有效果：

\>>>

```
 >>>  导入 asyncio

>>>  async  def  main  （）：
...  print  （ “Hello ...”  ）
...  等待 asyncio  。 睡觉 （ 1  ）
...  打印 （ “世界！”  ）

>>>  routine  =  main  （）
>>>  例程
<coroutine object main at 0x1027a6150>
```

记得`asyncio.run()`通过调度`main()`协程（未来对象）在事件循环上执行来实际强制执行：

\>>>

```
 >>>  asyncio  。 跑 （ 常规 ）
你好...... 
世界！
```

（其他协同程序可以被执行`await`，这是典型的只是包装`main()`的`asyncio.run()`，并与链协同程序`await`会从那里叫。）

**＃2：**默认情况下，异步IO事件循环在单个线程和单个CPU核心上运行。通常，在一个CPU内核中运行一个单线程事件循环是绰绰有余的。还可以跨多个核心运行事件循环。请查看[John Reese的演讲，](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/0kXaLh8Fz3k%3Ft%3D10m30s&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiHmwLnYIXAI1uSC3yIu1JvyeBRkA)了解更多信息，并警告您的笔记本电脑可能会自燃。

**＃3。**事件循环是可插入的。也就是说，如果你真的想要的话，你可以编写自己的事件循环实现并让它运行任务完全相同。这在[`uvloop`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/MagicStack/uvloop&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj4574_om8WfwK3Kms5qYl3q308DQ)包中得到了很好的证明，它是Cython中事件循环的一个实现。

这就是术语“可插入事件循环”的含义：您可以使用事件循环的任何工作实现，与协同程序本身的结构无关。所述`asyncio`包本身附带[两个不同的事件循环的实现](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/asyncio-eventloop.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgmAsUGarQHOht7DzNY0CR2q3f46w#event-loop-implementations)，用默认的是基于所述上[`selectors`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/selectors.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiVdAheDPlmPPXJWyA5uNP2pa96dw#module-selectors)模块。（第二种实现仅适用于Windows。）

## 完整程序：异步请求

你已经做到了这一点，现在是时候进行有趣而无痛的部分了。在本节中，您将`areq.py`使用`aiohttp`一个超快速的异步HTTP客户端/服务器框架构建一个Web抓取URL收集器。（我们只需要客户端部分。）这样的工具可用于映射站点集群之间的连接，链接形成有[向图](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://en.wikipedia.org/wiki/Directed_graph&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjdIkYb_x1mAu3sX6OAUZh6R6otrA)。

**注意**：您可能想知道为什么Python的`requests`包与async IO不兼容。`requests`建立在它之上`urrlib3`，而后者又使用Python `http`和`socket`模块。

默认情况下，套接字操作是阻塞的。这意味着Python不会喜欢`await requests.get(url)`因为`.get()`不等待。相比之下，几乎所有的东西`aiohttp`都是等待的协程，例如[`session.request()`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiohttp/blob/508adbb656da2e9ae660da5e98e1e5fa6669a3f4/aiohttp/client.py&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgW3I0L2I1ZVxSA2BsuuBL4BfLycA#L225)和[`response.text()`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiohttp/blob/da75122f6089a250128d2736f2bd88d10e97ca17/aiohttp/client_reqrep.py&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjlsYXCulz_4GXvE-Ux4PmX9V6Xkg#L913)。这是一个很棒的软件包，但是你`requests`在异步代码中使用它本身就是一种损害。

高级程序结构如下所示：

1. 从本地文件中读取一系列URL `urls.txt`。
2. 发送对URL的GET请求并解码生成的内容。如果失败，请停在那里寻找URL。
3. `href`在响应的HTML中搜索标记内的URL 。
4. 写结果到`foundurls.txt`。
5. 尽可能异步和并发地完成上述所有操作。（`aiohttp`用于请求和`aiofiles`文件附加。这是IO的两个主要示例，非常适合异步IO模型。）

这是内容`urls.txt`。它并不庞大，并且主要包含高度流量的网站：

```
 $ cat urls.txt
 https://regex101.com/ 
https://docs.python.org/3/this-url-will-404.html 
https://www.nytimes.com/guides/ 
https：// www.mediamatters.org/ 
https://1.1.1.1/ 
https://www.politico.com/tipsheets/morning-money 
https://www.bloomberg.com/markets/economics 
https：//www.ietf。组织/ RFC / rfc2616.txt
```

列表中的第二个URL应返回404响应，您需要优雅地处理该响应。如果您正在运行此程序的扩展版本，您可能需要处理比这更多的问题，例如服务器断开连接和无限重定向。

请求本身应使用单个会话进行，以利用会话内部连接池的重用。

我们来看看完整的程序。我们将在以下步骤中逐步完成：

```
 ＃！/ usr / bin / env python3 
＃areq.py

msgstr“”“异步获取嵌入多页HMTL的链接。”“

 导入 asyncio
导入 日志
导入 重新
导入 sys 
， 输入 import  IO 
import  urllib.error 
import  urllib.parse

 从aiohttp import ClientSession 导入aiofiles 
import  aiohttp
   

记录 。 basicConfig  （
    格式 =  “  ％（asctime）■  ％（levelname）■ ：％（名）■ ：％（消息）类” ，级别= 日志记录。DEBUG ，datefmt = “％H：％M：％S” ，流= SYS ，标准错误，        
         
       
         
 ）
logger  =  日志记录 。 getLogger  （ “areq”  ）
日志记录 。 getLogger  （ “chardet.charsetprober”  ） 。 disabled  =  True

HREF_RE  =  重新 。 编译 （ [R  'HREF = “（。*？）”'  ）

async  def  fetch_html  （ url  ： str  ， session  ： ClientSession  ， **  kwargs  ） - >  str  ：
    “”“GET请求包装器以获取页面HTML。

 kwargs传递给`session.request（）`。
 “””

    resp  =  等待 会话 。 请求 （ method  =  “GET”  ， url  =  url  ， **  kwargs  ）
    resp  。 raise_for_status  （）
    记录器 。 信息 （ “得到响应[  ％S  ]的网址： ％s的 ”  ， RESP  ， 状态 ， 网址 ）
    HTML  =  等待 RESP  。 text  （）
    返回 html

async  def  parse  （ url  ： str  ， session  ： ClientSession  ， **  kwargs  ） - >  set  ：
    “”“在`url`的HTML中查找HREF。”“” 
    found  =  set  （）
    try  ：
        html  =  await  fetch_html  （ url  =  URL  ， 会话 =  会话 ， **  kwargs  ）
    除 （
        aiohttp  。 ClientError  ，
        aiohttp  。 http_exceptions  。 HttpProcessingError  ，
    ） 为 e  ：
        logger  。 错误 （
            “  ％s  [  ％s  ]： ％s的 aiohttp异常”  ，
            url  ，
            getattr  （ e  ， “status”  ， 无 ），
            getattr  （ e  ， “message”  ， None  ），
         ）
        返回 发现
    除了 Exception  为 e  ：
        logger  。 异常 （
            “发生非aiohttp异常： ％s  ”  ， getattr  （ e  ， “  __ dict__ ” ， {}）
         ）
        返回 发现
     否则 ：
        对于 链接 在 HREF_RE  。 findall  （ html  ）：
            try  ：
                abslink  =  urllib  。 解析 。 urljoin  （ 网址 ， 链接 ）
            除 （ urllib的 。 错误 。 URLError  ， ValueError异常 ）：
                记录仪 。 异常 （ “解析URL错误： ％s  ”  ， 链接 ）
                传递
             否则 ：
                发现 。 添加 （ abslink  ）
        记录器 。 info  （ “找到 ％ s的％d个链接 ” ，len （找到），url ）返回找到        
         

async  def  write_one  （ file  ： IO  ， url  ： str  ， **  kwargs  ） - >  None  ：
    “”“将找到的HREF从`url`写入`file`。”“” 
    res  =  await  parse  （ url  =  url  ， **  kwargs  ）
    如果 不是 res  ：
         返回 无
     与 aiofiles  异步。 打开 （ 文件 ， “一”  ） 作为 ˚F  ：
        对于 p  在 RES  ：
            伺机 ˚F  。 写 （ f  “  {url}  \ t  {p}  \ n  ”  ）
        记录器 。 info  （ “为源URL写了结果： ％s  ”  ， url  ）

async  def  bulk_crawl_and_write  （ file  ： IO  ， urls  ： set  ， **  kwargs  ） - >  None  ：
    “”“同时抓取并写入多个`url`的`file`。”“” 
    与ClientSession （）async  as session ：tasks = [] 对于URL 中的URL ：任务。append （write_one （file = file ，url = url ，     
          
            
               
                          session  =  session  ， **  kwargs  ）
             ）
        等待 asyncio  。 聚集 （ *  任务 ）

 如果 __name__ == “ __ main__ ” ：
    import  pathlib 
    import  sys

    断言 系统 。 VERSION_INFO  > =  （ 3  ， 7  ），“ 脚本需要Python 3.7+”。
    here  =  pathlib  。 路径 （ __file__  ） 。 亲

    与 开放 （ 这里 。 joinpath  （ “urls.txt”  ）） 作为 infile中 ：
        网址 =  设定 （ 地图 （ STR  。 条 ， infile中 ））

    outpath  =  here  。 joinpath  （ “foundurls.txt”  ）
    with  open  （ outpath  ， “w”  ） as  outfile  ：
        outfile  。 write  （ “source_url  \ t  parsed_url  \ n  ”  ）

    asyncio  。 run  （ bulk_crawl_and_write  （ file  =  outpath  ， urls  =  urls  ））
```

这个脚本比我们最初的玩具程序要长，所以让我们分解它。

常量`HREF_RE`是一个正则表达式，用于提取我们最终要搜索的内容，`href`HTML中的标记：

\>>>

```
 >>>  HREF_RE  。 搜索 （ '转到<a href="https://realpython.com/"> Real Python </a>'  ）
<re.Match对象; span =（15,45），match ='href =“https://realpython.com/”'>
```

协程`fetch_html()`是GET请求的包装器，用于发出请求并解码生成的页面HTML。它提出请求，等待响应，并在非200状态的情况下立即提出：

```
 resp  =  等待 会话 。 请求 （ method  =  “GET”  ， url  =  url  ， **  kwargs  ）
resp  。 raise_for_status  （）
```

如果状态正常，则`fetch_html()`返回页面HTML（a `str`）。值得注意的是，此功能中没有异常处理。逻辑是将该异常传播给调用者并让它在那里处理：

```
 html  =  await  resp  。 文字 （）
```

我们`await` `session.request()`和`resp.text()`，因为他们是awaitable协同程序。否则，请求/响应周期将是应用程序的长尾占用时间部分，但是使用异步IO，`fetch_html()`允许事件循环在其他可用的作业上工作，例如解析和写入已经获取的URL。

接下来在coroutines链中`parse()`，等待`fetch_html()`给定的URL，然后`href`从该页面的HTML中提取所有标记，确保每个标记都有效并将其格式化为绝对路径。

不可否认，第二部分`parse()`是阻塞，但它包含快速正则表达式匹配，并确保发现的链接成为绝对路径。

在这种特定情况下，此同步代码应该快速且不显眼。但只要记住一个给定的协程内的任何行会阻碍其他协同程序，除非该行使用`yield`，`await`或`return`。如果解析是一个更密集的过程，您可能需要考虑在其自己的进程中运行此部分[`loop.run_in_executor()`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/library/asyncio-eventloop.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgmAsUGarQHOht7DzNY0CR2q3f46w#executing-code-in-thread-or-process-pools)。

接下来，协程`write()`获取一个文件对象和一个URL，并等待`parse()`返回一个`set`已解析的URL，通过使用`aiofiles`异步文件IO的包，将每个URL与其源URL 异步写入文件。

最后，`bulk_crawl_and_write()`作为脚本的协程链的主要入口点。它使用单个会话，并为最终读取的每个URL创建任务`urls.txt`。

以下是值得一提的几点：

- 默认情况下`ClientSession`，[适配器](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://aiohttp.readthedocs.io/en/stable/client_reference.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgOQYuwZU-Th14WjgS4noEljNkgMQ#connectors)最多可以打开100个连接。要改变这种状况，通过实例`asyncio.connector.TCPConnector`来`ClientSession`。您还可以基于每个主机指定限制。
- 您可以为整个会话和单个请求指定最大[超时](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://aiohttp.readthedocs.io/en/stable/client_quickstart.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhAMzcJ3AMCdKoZYo0RmsW5D8XXSA#timeouts)。
- 此脚本也使用`async with`，它与[异步上下文管理器一起使用](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0492/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj-vAvUSsoVkXqjv876EC8vutbf9A#asynchronous-context-managers-and-async-with)。我没有专门讨论这个概念，因为从同步到异步上下文管理器的转换相当简单。后者必须定义`.__aenter__()`和`.__aexit__()`，而不是`.__exit__()`和`.__enter__()`。正如您所料，`async with`只能在声明的coroutine函数中使用`async def`。

如果您想再探索一下，GitHub上本教程的[配套文件](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/realpython/materials/tree/master/asyncio-walkthrough&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgpSttDpfz9kKIcwArTCGZp1xcOVg)也附有评论和文档字符串。

这是在所有荣耀中的执行，如`areq.py`获取，解析，并在一秒钟内保存9个URL的结果：

```
 $ python3 areq.py
 21:33:22 DEBUG：asyncio：使用selector：KqueueSelector 
21:33:22 INFO：areq：得到了URL的响应[200]：https：
//www.mediamatters.org/ 21:33:22信息：areq：找到115个链接https://www.mediamatters.org/ 
21:33:22 INFO：areq：得到了URL的响应[200]：https：//www.nytimes.com/guides/ 
21:33 ：22 INFO：areq：得到了URL的响应[200]：https 
：//www.politico.com/tipsheets/morning-money 21:33:22 INFO：areq：得到了URL的响应[200]：https：// www.ietf.org/rfc/rfc2616.txt 
21:33:22错误：areq：https://docs.python.org/3/this-url-will-404.html [404]的aiohttp例外：未找到
21:33:22信息：areq：找到120个链接https://www.nytimes.com/guides/
21:33:22信息：areq：找到143个链接https://www.politico.com/tipsheets/morning-money 
21:33:22信息：areq：写了源URL的结果：https：//www.mediamatters .org / 
21:33:22信息：areq：找到0链接https://www.ietf.org/rfc/rfc2616.txt 
21:33:22信息：areq：得到的回复[200]为URL：https： //1.1.1.1/ 
21:33:22 INFO：areq：写了源URL的结果：https 
：//www.nytimes.com/guides/ 21:33:22 INFO：areq：写了源URL的结果：https： //www.politico.com/tipsheets/morning-money 
21:33:22 INFO：areq：得到了网址的响应[200]：https：
//www.bloomberg.com/markets/economics 21:33:22信息： areq：找到3个链接https://www.bloomberg.com/markets/economics
21:33:22信息：areq：写了源URL的结果：https 
：//www.bloomberg.com/markets/economics 21:33:23 INFO：areq：找到36个链接https://1.1.1.1/ 
21 ：33：23信息：areq：得到回复[200]的URL：https 
：//regex101.com/ 21:33:23 INFO：areq：找到23个链接https://regex101.com/ 
21:33:23信息：areq：写了源URL的结果：https 
：//regex101.com/ 21:33:23 INFO：areq：写了源URL的结果：https ：//1.1.1.1/
```

那不算太破旧！作为完整性检查，您可以检查输出的行数。在我的情况下，它是626，但请记住，这可能会波动：

```
 $ wc -l foundurls.txt
 626 foundurls.txt

$ head -n 3 foundurls.txt
 source_url parsed_url 
https://www.bloomberg.com/markets/economics https://www.bloomberg.com/feedback 
https://www.bloomberg.com/markets/economics https：/ /www.bloomberg.com/notices/tos
```

**后续步骤**：如果您想提高赌注，请将此webcrawler递归。您可以使用它[`aio-redis`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aioredis&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhjqfBE62kAWuVakwWihsdSjY0a_A)来跟踪树中已爬网的URL，以避免请求它们两次，并使用Python的`networkx`库连接链接。

记得要好。向一个小的，毫无防备的网站发送1000个并发请求是坏的，坏的，坏的。有一些方法可以限制您在一个批次中进行的并发请求数量，例如使用[sempahore](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://stackoverflow.com/q/40836800/7954504&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhwMZf2Y3ReUpIAX9pZplvK9d7lDg)对象`asyncio`或使用[类似这样](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.artificialworlds.net/blog/2017/05/31/python-3-large-numbers-of-tasks-with-limited-concurrency/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjI3AmDI5rGj5CpsjYixssmfeYbjA)的模式。如果你不注意这个警告，你可能会得到大量的`TimeoutError`例外，最终只会伤害你自己的程序。

## 上下文中的异步IO

现在您已经看到了健康的代码量，让我们退一步，考虑异步IO何时是一个理想的选择，以及如何进行比较以得出该结论或以其他方式选择不同的并发模型。

### 何时以及为何Async IO是正确的选择？

本教程不适用于异步IO与线程与多处理的扩展论述。但是，了解异步IO何时可能是三者中的最佳候选者是有用的。

对异步IO与多处理的争夺根本不是一场战斗。事实上，它们可以一起[使用](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/0kXaLh8Fz3k%3Ft%3D10m30s&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiHmwLnYIXAI1uSC3yIu1JvyeBRkA)。如果你有多个相当统一的CPU绑定任务（一个很好的例子是在诸如或的库中进行[网格搜索](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://scikit-learn.org/stable/modules/grid_search.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjtkxirAXRR2BLit3bPxLt9k_-1uw#parallelism)），多处理应该是一个明显的选择。`scikit-learn``keras`

`async`如果所有函数都使用阻塞调用，那么简单地在每个函数之前放置是个坏主意。（这实际上可能会降低您的代码速度。）但如前所述，有些地方异步IO和多处理可以[协调一致](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/0kXaLh8Fz3k%3Ft%3D10m30s&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiHmwLnYIXAI1uSC3yIu1JvyeBRkA)。

异步IO和线程之间的竞争更直接一些。我在介绍中提到“线程很难。”完整的故事是，即使在线程似乎易于实现的情况下，由于竞争条件和内存使用等原因，它仍然可能导致臭名昭着的无法跟踪的错误。的东西。

线程也比异步IO更容易扩展，因为线程是具有有限可用性的系统资源。在许多机器上创建数千个线程会失败，我不建议首先尝试它。创建数千个异步IO任务是完全可行的。

当您有多个IO绑定任务时，异步IO会闪烁，否则任务将通过阻止IO绑定等待时间来控制，例如：

- 网络IO，无论您的程序是服务器还是客户端
- 无服务器设计，例如点对点，多用户网络，如组聊天室
- 读/写操作，你想要模仿“发射后不管”的风格，但不要担心对你正在阅读和写入的内容持有锁定

不使用它的最大原因是`await`只支持定义一组特定方法的特定对象集。如果要对某个DBMS执行异步读取操作，则不仅需要查找该DBMS的Python包装器，还需要查找支持`async`/ `await`syntax 的Python包装器。包含同步调用的协同程序会阻止其他协同程序和任务运行。

有关与`async`/ 一起使用的库`await`的[列表](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/async-io-python/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiL1Xk3QWc_w5RYhDWXj8phEnjvRw#libraries-that-work-with-asyncawait)，请参阅本教程末尾的[列表](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/async-io-python/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiL1Xk3QWc_w5RYhDWXj8phEnjvRw#libraries-that-work-with-asyncawait)。

### 异步IO它是，但是哪一个？

本教程重点介绍异步IO，`async`/ `await`语法，以及`asyncio`用于事件循环管理和指定任务。`asyncio`当然不是唯一的异步IO库。Nathaniel J. Smith的观察结果很多：

> [在]几年后，`asyncio`可能会发现自己会成为精明的开发人员避免使用的stdlib库之一`urllib2`。
>
> ...
>
> 实际上，我所争论的是，它`asyncio`是自身成功的牺牲品：在设计时，它采用了最好的方法; 但从那以后，受到启发的工作`asyncio`- 比如添加`async`/ `await`- 已经改变了景观，使我们可以做得更好，现在`asyncio`被其先前的承诺所束缚。[（资源）](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgjRs-m-BipplImEevSPayoRCavww)

为此，一些大牌的替代品是做什么`asyncio`呢，尽管有不同的API和不同的做法，是[`curio`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/dabeaz/curio&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiAVpLskxuAPy8TH_E9xToqTbYZPQ)和[`trio`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/python-trio/trio&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgDlp9vfAVOch57WYTKmBrUix7SqA)。就个人而言，我认为如果你正在构建一个中等规模，简单易用的程序，只需使用`asyncio`就足够了，并且可以理解，并且可以避免在Python的标准库之外添加另一个大的依赖项。

但是，无论如何，请查看`curio`并且`trio`，您可能会发现他们以对用户更直观的方式完成相同的操作。此处介绍的许多与包不相关的概念也应该渗透到备用异步IO包中。

## 什物

在接下来的几节中，您将涵盖到目前为止尚未完全适合本教程的一些杂项部分`asyncio`和`async`/ `await`，但对于构建和理解完整程序仍然很重要。

### 其他顶级`asyncio`功能

除此之外`asyncio.run()`，您还看到了一些其他的包级功能，例如`asyncio.create_task()`和`asyncio.gather()`。

您可以使用`create_task()`来安排协程对象的执行，然后`asyncio.run()`：

\>>>

```
 >>>  导入 asyncio

>>>  async  def  coro  （ seq  ） - >  list  ：
...  “”'''IO'等待时间与最大元素成正比。“”“ 
......  等待 asyncio  。 sleep  （ max  （ seq  ））
...  返回 列表 （ 反向 （ seq  ））
 ...
>>>  异步 高清 主 （）：
...  ＃这是一个任务的情况下有点多余
...  ＃我们可以使用'等待科罗（[3，2，1]）自身` 
...  t  =  asyncio  。 create_task  （ 科罗 （[  3  ， 2  ， 1  ]））  ＃的Python 3.7+ 
...  等待 吨
...  打印 （ ˚F  'T：类型{类型（T）}'  ）
...  打印 （ ˚F  “吨完成： {t.done（）}'  ）
 ...
>>>  t  =  asyncio  。 run  （ main  （））
t：type <class'_asyncio.Task'> 
t done：True
```

这种模式有一个微妙之处：如果你不在`await t`内部`main()`，它可能会在`main()`它自己发出信号之前完成。因为`asyncio.run(main())` [调用`loop.run_until_complete(main())`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/python/cpython/blob/7e18deef652a9d413d5dbd19d61073ba7eb5460e/Lib/asyncio/runners.py&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhieAh-yi5vM7Cr-WerClLKexEKA5w#L43)，事件循环仅涉及（不`await t`存在）`main()`完成，而不是完成内部创建的任务`main()`。如果没有`await t`，循环的其他任务[将被取消](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/python/cpython/blob/7e18deef652a9d413d5dbd19d61073ba7eb5460e/Lib/asyncio/runners.py&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhieAh-yi5vM7Cr-WerClLKexEKA5w#L46)，可能在它们完成之前。如果您需要获取当前待处理任务的列表，则可以使用`asyncio.Task.all_tasks()`。

**注意**：`asyncio.create_task()`在Python 3.7中引入。在Python 3.6或更低版本中，使用`asyncio.ensure_future()`代替`create_task()`。

另外，还有`asyncio.gather()`。虽然它没有做任何非常特别的事情，但`gather()`意味着将一系列协程（期货）整齐地放入一个未来。因此，它返回一个未来的对象，如果您`await asyncio.gather()`指定多个任务或协同程序，则表示您正在等待所有这些对象完成。（这与`queue.join()`我们之前的示例有些相似。）结果`gather()`将是输入中的结果列表：

\>>>

```
 >>>  导入 时间
>>>  async  def  main  （）：
...  t  =  asyncio  。 create_task  （ 科罗 （[  3  ， 2  ， 1  ]））
...  T2  =  ASYNCIO  。 create_task  （ 科罗 （[  10  ， 5  ， 0  ]））  ＃的Python 3.7+ 
...  打印 （ '开始：'  ， 时间 。 的strftime  （ '  ％X  '  ））
... a  =  等待 asyncio  。 聚 （ 牛逼 ， T2  ）
...  打印 （ '结束：'  ， 时间 。 strftime的 （ '  ％X  '  ））  ＃应为10秒
...  打印 （ ˚F  “完成这两项任务：{所有（（t.done（ ），t2.done（）））}'  ）
...  返回 一个
 ...
>>>  a  =  asyncio  。 run  （ main  （））
开始：16 
：20 
：11 结束：16 ：20 ：21 两个任务完成：真
>>>  a 
[[1,2,3]，[ 0,5,10 ]]
```

您可能已经注意到`gather()`等待通过它的Futures或coroutines的整个结果集。或者，您可以`asyncio.as_completed()`按完成顺序循环以完成任务。该函数返回一个迭代器，在完成任务时生成任务。下面，结果`coro([3, 2, 1])`将在`coro([10, 5, 0])`完成之前可用，但情况并非如此`gather()`：

\>>>

```
 >>>  async  def  main  （）：
...  t  =  asyncio  。 create_task  （ 科罗 （[  3  ， 2  ， 1  ]））
...  T2  =  ASYNCIO  。 create_task  （ 科罗 （[  10  ， 5  ， 0  ]））
...  打印 （ '开始：'  ， 时间 。 的strftime  （ '  ％X  '  ））
...  用于 水库 中 ASYNCIO  。 as_completed  （（ 吨 ， T2  ））：
...  并发症 =  伺机 RES 
...  打印 （ ˚F  'RES： {并发症}  完成了在{time.strftime（ “  ％X  ”）}'  ）
...  打印 （ “结束：”  ， 时间 。 strftime的 （ '  ％X  '  ））
...  打印 （ ˚F  '完成这两项任务：{所有（（t.done（），t2.done（）））}'  ）
 ...
>>>  a  =  asyncio  。 run  （ main  （））
开始：09：49：07 
res：[1,2,3]于09:49:10完成
res：[0,5,10]于09:49:17完成
结束：
09 ：49 ：17 这两项任务都完成了：真的
```

最后，您可能也会看到`asyncio.ensure_future()`。您应该很少需要它，因为它是一个较低级别的管道API并且在很大程度上被替换`create_task()`，后面会介绍。

### 的优先权 `await`

虽然它们的行为有些相似，但`await`关键字的优先级明显高于`yield`。这意味着，因为它绑定得更紧密，所以在一些实例中，您需要在`yield from`语句中使用括号，而这些括号在类似`await`语句中不是必需的。有关更多信息，请参阅PEP 492中[的`await`表达式示例](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0492/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj-vAvUSsoVkXqjv876EC8vutbf9A#examples-of-await-expressions)。

## 结论

您现在已经准备好使用`async`/ `await`和它构建的库。以下是您所介绍的内容的概述：

- 异步IO作为语言不可知模型，通过让协同程序间接地相互通信来实现并发性的方法
- Python的新特性`async`和`await`关键字的细节，用于标记和定义协同程序
- `asyncio` ，Python包，提供运行和管理协同程序的API

## 资源

### Python版本细节

Python中的异步IO已经迅速发展，很难跟踪到底发生了什么。以下是与Python相关的Python次要版本更改和介绍的列表`asyncio`：

- 3.3：`yield from`表达式允许生成器委派。
- 3.4：`asyncio`在具有临时API状态的Python标准库中引入。
- 3.5：`async`并`await`成为Python语法的一部分，用于表示和等待协同程序。它们还没有保留关键字。（您仍然可以定义函数或变量命名`async`和`await`）。
- 3.6：引入了异步生成器和异步理解。`asyncio`宣布的API 是稳定的而不是临时的。
- 3.7：`async`并`await`成为保留关键字。（它们不能用作标识符。）它们旨在取代`asyncio.coroutine()`装饰器。在[一系列其他功能中](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/whatsnew/3.7.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjDHFqCindy6yOwACZekyvrJiv3jg#whatsnew37-asyncio)`asyncio.run()`介绍了该`asyncio`软件包。

如果您想要安全（并且能够使用`asyncio.run()`），请使用Python 3.7或更高版本来获得全套功能。

### 用品

以下是其他资源的精选列表：

- 真正的Python：[使用并发加速Python程序](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/python-concurrency/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj7jlHmShkPasEhJes3KiLWOSQXTQ)
- 真正的Python：[什么是Python全局解释器锁？](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://realpython.com/python-gil/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjz97tiQYiTwKq0TsJwF535l-s4Sw)
- CPython：`asyncio`包[源](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/python/cpython/tree/master/Lib/asyncio&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjjDuUoRXKv_IojCAlaxCKQPrw3JQ)
- Python文档：[数据模型>协同程序](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/reference/datamodel.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgloGIC6SbCrWZXzftgPIaOg9NeOw#coroutines)
- TalkPython：[Python中的异步技术和示例](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://training.talkpython.fm/courses/details/async-in-python-with-threading-and-multiprocessing&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhg23O6s-ZZLdpnQLi3RZTjne2U8_A)
- Brett Cannon：[Heck如何在Python 3.5中进行Async-Await工作？](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhmPB3072CN1ysUo--ncMXlPwvYww)
- PYMOTW： [`asyncio`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://pymotw.com/3/asyncio/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjOgSZkib_YNZoARU-pKwaoBwYbLg)
- A. Jesse Jiryu Davis和Guido van Rossum：[使用asyncio Coroutines的网络爬虫](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhi2TA8RbSI56_w20DbvPUTDp2sNxA)
- Andy Pearce：[Python协同程序的状态：`yield from`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://www.andy-pearce.com/blog/posts/2016/Jun/the-state-of-python-coroutines-yield-from/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhcYypX3ZG50HSuClU6ThzF9I9zFA)
- Nathaniel J. Smith：[关于后`async`/ `await`世界中异步API设计的一些想法](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgjRs-m-BipplImEevSPayoRCavww)
- Armin Ronacher：[我不懂Python的Asyncio](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjPpuprequIDzL2rQD_rtFJLIz4Pg)
- Andy Balaam：[关于`asyncio`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://www.artificialworlds.net/blog/2017/05/31/basic-ideas-of-python-3-asyncio-concurrency/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjLDRQ3nA65CpMffQargoYwbPF3eA)（4个帖子）
- Stack Overflow：[Python `asyncio.semaphore`in `async`- `await`function](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://stackoverflow.com/q/40836800/7954504&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhwMZf2Y3ReUpIAX9pZplvK9d7lDg)
- Yeray Diaz：
  - [工作Python开发人员的AsyncIO](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjnoLGjIHMtTmApPkfYGgSBgWVHpQ)
  - [Asyncio协同模式：超越 `await`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://medium.com/python-pandemonium/asyncio-coroutine-patterns-beyond-await-a6121486656f&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhh2PZ5nQ8JtoRmK98_Er1V_KG6fYQ)

一些Python *新的*部分更详细地解释了语言变化背后的动机：

- [Python 3.3](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/whatsnew/3.3.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhIggoz29Wk9x32ATqFXfBMAneXmQ#pep-380)（`yield from`和PEP 380）的新功能
- [Python 3.6中的新功能](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://docs.python.org/3/whatsnew/3.6.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiMGwxzTi-NbJqhd5YtPJyVdiqD6A#whatsnew36-pep525)（PEP 525和530）

来自David Beazley：

- [生成器：系统程序员的技巧](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://www.dabeaz.com/generators/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgvUmqDtB-B09TWR73-qhiX_cL6pA)
- [关于协程和并发的好奇课程](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://www.dabeaz.com/coroutines/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgKtXQSCKa1Vi_5pf93s8C5QzEAig)
- [发电机：最后的边疆](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=http://dabeaz.com/finalgenerator/index.html&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjrtdvEE2Kx-PbAkRc7KeGFNvUpkQ)

YouTube会谈：

- [John Reese - 使用AsyncIO和Multiprocessing在GIL之外思考 - PyCon 2018](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/0kXaLh8Fz3k&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiQ3PPDEBF26UmMlCEBFgEsf2vSlQ)
- [主题演讲David Beazley - 感兴趣的主题（Python Asyncio）](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/ZzfHjytDceU&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjeLAlTOSTyLdBCwJ4ETvM7D9Vtuw)
- [David Beazley - 从头开始的Python并发：现场！ - PyCon 2015](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/MCs5OvhV9S4&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhkkJdN01Ap2beoEKUvCY4fvK2_vw)
- [Raymond Hettinger，关于并发的主题演讲，PyBay 2017](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/9zinZmE3Ogk&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhH0-y_dvzlgPoviJJVjliO4wHO8Q)
- [思考并发性，Python核心开发人员Raymond Hettinger](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/Bv25Dwe84g0&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhi8yW_3N0-vvgVO_P6HEU3bjDWZGQ)
- [完全初学者PyCon 2017的Miguel Grinberg异步Python](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/iG6fr81xHKA&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiMMv_GgzQpuVw87O7BHvsFmHqRVA)
- [Yury Selivanov asyncawait和asyncio在Python 3 6及更高版本的PyCon 2017中](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/2ZFFv-wZ8_g&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjsV5O9dcls882lQEuDAHdbNOOACA)
- [在异步中的恐惧和等待：一个到达Coroutine梦想之心的野蛮之旅](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/E-1Y4kSsAFc&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj7M8pim6nW0QDi-e10TtSI1DWaXw)
- [什么是异步，它是如何工作的，我什么时候应该使用它？（PyCon APAC 2014）](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://youtu.be/kdzL3r-yJZY&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjora0yHhrAv9oGwCW-xKB0UbNHtw)

### 相关的PEP

| PEP                                                          | 创建日期   |
| ------------------------------------------------------------ | ---------- |
| [PEP 342 - 通过增强型发电机的协同程序](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0342/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhibfLGOnbxaLjnIpVR12WxheeQE3A) | 2005-05    |
| [PEP 380 - 委托给子发电机的语法](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0380/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiQjbwZPd_rQkhu-jp6GAqSNUwFHg) | 2009年02期 |
| [PEP 3153 - 异步IO支持](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-3153/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhimaFDr0rVEh2bXog6Noa6Bo-U2ZA) | 2011-05    |
| [PEP 3156 - 重新启动异步IO支持：“asyncio”模块](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-3156/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgnPhgOeU2lZx0UOPVaLWFO9MwIcA) | 2012-12    |
| [PEP 492 - 具有异步和等待语法的协同程序](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0492/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj-vAvUSsoVkXqjv876EC8vutbf9A) | 2015-04    |
| [PEP 525 - 异步发电机](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0525/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiVh16y2l_g-1xaF-MrrD50lrNGSQ) | 2016-07    |
| [PEP 530 - 异步理解](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://www.python.org/dev/peps/pep-0530/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiDF470rfOkx8sogYcx-EfgLAbphQ) | 2016-09    |

### 与之合作的图书馆`async`/`await`

来自[aio-libs](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj7Vf9QfYbfGGwj4r_a6CaEtvGkDQ)：

- [`aiohttp`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiohttp&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgXcJISAvDG_0NYb74EGaOtCbDRzw) ：异步HTTP客户端/服务器框架
- [`aioredis`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aioredis&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhjqfBE62kAWuVakwWihsdSjY0a_A) ：Async IO Redis支持
- [`aiopg`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiopg&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhqjfsg43g8k8rHpzm-MsCry6nW_g) ：Async IO PostgreSQL支持
- [`aiomcache`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiomcache&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhh-D77ctmUlmS7wtUf_O-6l5DIAIw) ：Async IO memcached客户端
- [`aiokafka`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiokafka&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhi4fi8busOEERgVet35w3s-wMohYA) ：Async IO Kafka客户端
- [`aiozmq`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiozmq&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjKVs2VrfOrF7lkoiky6-KPDsECNw) ：Async IO ZeroMQ支持
- [`aiojobs`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/aiojobs&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgfcaxXNJ2xWn7jBvj6EaQlMZoEIQ) ：用于管理后台任务的作业调度程序
- [`async_lru`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/aio-libs/async_lru&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhib51TBm3LEpFM2jfHC5opjMvW-XQ) ：用于异步IO的简单LRU缓存

来自[魔术堆](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://magic.io/&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhi-eYywmvQ5i8pS38ao9HMd-gYYfw)：

- [`uvloop`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/MagicStack/uvloop&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhj4574_om8WfwK3Kms5qYl3q308DQ) ：超快的异步IO事件循环
- [`asyncpg`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/MagicStack/asyncpg&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgQUEYMedZirUKar4FRyNybELlPiw) :(也非常快）async IO PostgreSQL支持

来自其他主机：

- [`trio`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/python-trio/trio&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgDlp9vfAVOch57WYTKmBrUix7SqA)：Friendlier `asyncio`打算展示一个简单明了的设计
- [`aiofiles`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/Tinche/aiofiles&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgvR7TVvA6qq693-4-oBjH_bJYYdQ) ：异步文件IO
- [`asks`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/theelous3/asks&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhiAinvOdg_D__GJElktaBhkP-Kcug) ：异步请求 - 就像http库一样
- [`asyncio-redis`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/jonathanslenders/asyncio-redis&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhicLzsXGzd3MHCmX7uRqG4eJc58Sw) ：Async IO Redis支持
- [`aioprocessing`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/dano/aioprocessing&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhgvs_hUhbgStw01037Khnuim-va3w)：集成`multiprocessing`模块`asyncio`
- [`umongo`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/Scille/umongo&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhhKuFwgpCn-K9WRwYn-dTjfp1e1fQ) ：Async IO MongoDB客户端
- [`unsync`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/alex-sherman/unsync&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhjIxCJRzMI0psbQ086oZ6j-nmoOhg) ：不同步 `asyncio`
- [`aiostream`](https://translate.googleusercontent.com/translate_c?act=url&depth=1&ie=UTF8&prev=_t&rurl=translate.google.com&sl=auto&sp=nmt4&tl=zh-CN&u=https://github.com/vxgmichel/aiostream&xid=17259,15700019,15700124,15700186,15700190,15700201,15700248&usg=ALkJrhibYJTwM0eq5Bn7IiIpNqaUyTy8zQ)：喜欢`itertools`，但异步